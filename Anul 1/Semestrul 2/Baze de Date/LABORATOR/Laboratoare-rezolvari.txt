--lab1
-- SELECT --CLAUZA OBLIGATORIE CAND SE SCRIE COMANDA SELECT
--     UPPER(FIRST_NAME) AS NUME_MAJ, --UN ALIAS SE POATE ADAUGA CU SAU FARA UTILIZAREA LUI 'AS'
--     EMPLOYEE_ID "Id angajat", --DACA ETICHETA CONTINE CARACTERE 'BLANK', ATUNCI ETICHETA SE TRECE INTRE GHILIMELE
--     SALARY * 12 "SALARIU ANUAL"
--CAMPURILE DIN CLAUZA SELECT SE SEPARA PRIN VIRGULA SI POT FI
                                    -- COLOANE ALE TABELULUI/TABELELOR DIN CLAUZA FROM,
                                    -- OPERATII APLICATE ASUPRA ANUMITOR COLOANE,
                                    -- FUNCTII APLICATE ASUPRA ANUMITOR COLOANE
                                    -- SUBCERERI (COMENZI SELECT IN CLAUZELE ALTOR COMENZI)
-- FROM EMPLOYEES --CLAUZA OBLIGATORIE CAND SE SCRIE COMANDA SELECT
-- WHERE SALARY != 10000
--         --DACA UN QUERY ARE MAI MULTE CONDITII, NU SE SCRIU MAI MULTE CLAUZE WHERE,
--             --CI SE SEPARA CONDITIILE FOLOSIND OPERATORII LOGICI 'AND', 'OR', 'NOT'
--         --OPERATORI DE COMPARATIE (=, <> sau !=, <, <=, >, >=)
-- ORDER BY "SALARIU ANUAL" DESC, HIRE_DATE;
--         --PENTRU FIECARE CRITERIU DE SORTARE TREBUIE SPECIFICAT TIPUL DE SORTARE (ASC/DESC)
--         --DACA NU SE SPECIFICA CRITERIUL DE SORTARE, BY DEFAULT ESTE ASC
--
-- SELECT
--     EMPLOYEE_ID,
--     FIRST_NAME
-- FROM EMPLOYEES;

-- --SAU
-- SELECT
--     EMPLOYEES.EMPLOYEE_ID,
--     EMPLOYEES.FIRST_NAME
-- FROM EMPLOYEES;

-- --SAU
-- SELECT
--     E.EMPLOYEE_ID,
--     E.FIRST_NAME
-- FROM EMPLOYEES E;

-- --SAU
-- SELECT
--     "TABEL ANGAJATI".EMPLOYEE_ID,
--     "TABEL ANGAJATI".FIRST_NAME
-- FROM EMPLOYEES "TABEL ANGAJATI";
-- --ETICHETAREA TABELELOR ESTE RECOMANDATA ATUNCI CAND CERERILE SUNT MAI COMPLEXE SI:
--     --FIE SE LUCREAZA CU MAI MULTE INSTANTE ALE UNUI ACELUIASI TABEL SI TREBUIE DIFERENTIATE COLOANELE UTILIZATE

-- SELECT
--     EMPLOYEE_ID,
--     FIRST_NAME
-- FROM EMPLOYEES, EMPLOYEES; --NU SE STIE DACA COLOANELE DIN SELECT TIN DE PRIMA SAU DE A DOUA INSTANTA A LUI EMPLOYEES
--
--     --FIE SE LUCREAZA CU TABELE CARE AU COLOANE CU ACEEASI DENUMIRE
-- SELECT
--     MANAGER_ID,
--     DEPARTMENT_ID
-- FROM EMPLOYEES, DEPARTMENTS; --NU SE STIE DACA COLOANELE DIN SELECT TIN DE TABELUL EMPLOYEES SAU DE TABELUL DEPARTMENTS (CELE 2 COLOANE APAR IN AMBELE TABELE)
--
-- --3
-- DESC EMPLOYEES; -- COMANDA NU ESTE RECUNOSCUTA IN DATAGRIP, SE POATE TESTA IN ORACLE SQL DEVELOPER INSA
--
-- --4
-- SELECT *
-- FROM EMPLOYEES; -- * AJUTA LA AFISAREA TUTUROR COLOANELOR TABELULUI/TABELELOR DIN CLAUZA FROM
--
-- SELECT *, EMPLOYEE_ID FROM EMPLOYEES; -- EROARE: DACA S-A UTILIZAT * IN CLAUZA SELECT, ATUNCI NU SE POT ADAUGA SI ALTE CAMPURI PARTICULARE IN CLAUZA
--
-- --5
-- SELECT
--     EMPLOYEE_ID,
--     FIRST_NAME,
--     JOB_ID,
--     HIRE_DATE
-- FROM EMPLOYEES;
--
-- --6
-- SELECT DISTINCT JOB_ID
-- FROM EMPLOYEES;
--
-- --nu prea se utilizeaza
-- SELECT UNIQUE JOB_ID
-- FROM EMPLOYEES;
--
-- --7
-- SELECT
--     FIRST_NAME || ', ' || JOB_ID --STRING-URILE SE DEFINESC CU APOSTROF, NU CU GHILIMELE
--                                     -- '' -> ECHIVALENT LUI NULL
--                                     --CU GHILIMELE SE DEFINESC DOAR ALIAS-URILE
-- FROM EMPLOYEES;
--
-- --8
-- SELECT
--     FIRST_NAME, SALARY
-- FROM EMPLOYEES
-- WHERE SALARY >= 2850;
--
-- --9
-- SELECT
--     FIRST_NAME,
--     DEPARTMENT_ID
-- FROM EMPLOYEES
-- WHERE EMPLOYEE_ID = 104;
--
-- --10
-- SELECT FIRST_NAME, SALARY
-- FROM EMPLOYEES
-- WHERE SALARY NOT BETWEEN 1500 AND 2850;
-- -- OPERATORUL BETWEEN ESTE FOLOSIT PENTRU VERIFICAREA APARTENENTEI UNEI VALORI LA UN INTERVAL INCHIS
--
-- --11
-- SELECT FIRST_NAME, JOB_ID, HIRE_DATE
-- FROM EMPLOYEES
-- WHERE HIRE_DATE BETWEEN '20-FEB-1987' AND '01-MAY-1989'; -- EXEMPLU DE CONVERSIE IMPLICITA DIN SIR DE CARACTERE IN DATA CALENDARISTICA
--
-- --12
-- SELECT FIRST_NAME, DEPARTMENT_ID
-- FROM EMPLOYEES
-- WHERE DEPARTMENT_ID IN (10, 30)
-- ORDER BY FIRST_NAME;
-- -- OPERATORUL IN ESTE FOLOSIT PENTRU VERIFICAREA APARTENENTEI UNEI VALORI LA O MULTIME
--
-- --13
-- SELECT
--     FIRST_NAME AS ANGAJAT,
--     SALARY * 12 "SALARIU ANUAL"
-- FROM EMPLOYEES
-- WHERE (SALARY >= 1500) AND
--         (DEPARTMENT_ID IN (10, 30))
--
-- --14
-- SELECT
--     FIRST_NAME, JOB_ID
-- FROM EMPLOYEES
-- WHERE MANAGER_ID IS NOT NULL;
--
-- --PENTRU A VERIFICA DACA O COLOANA ESTE NULL SAU NU, SE VA FOLOSI IS/IS NOT
--
-- -- CONDITIILE MANAGER_ID = NULL SI MANAGER_ID != NULL VOR RETURN 'UNKNOWN', NU 'TRUE'/'FALSE'
--
-- -- DACA SE VERIFICA 2 CONDITII, DINTRE CARE UNA IMPLICA 'UNKNOWN', VA REZULTA:
--     -- FALSE AND UNKNOWN -> FALSE
--     -- FALSE OR UNKNOWN -> UNKNOWN
--     -- TRUE OR UNKNOWN -> TRUE
--     -- TRUE AND UNKNOWN -> UNKNOWN
--
-- --15
-- SELECT
--     EMPLOYEE_ID, SALARY, COMMISSION_PCT
-- FROM EMPLOYEES
-- WHERE COMMISSION_PCT IS NOT NULL;
--
-- SELECT
--     EMPLOYEE_ID, SALARY, COMMISSION_PCT
-- FROM EMPLOYEES
-- ORDER BY SALARY DESC, COMMISSION_PCT DESC;
-- --LA SORTARE DESCRESCATOARE, NULL APARE INAINTEA VALORILOR NUMERICE
-- --LA SORTARE CRESCATOARE, NULL APARE DUPA VALORILE NUMERICE
--
--
-- -- LIKE ESTE FOLOSIT PENTRU A VERIFICA DACA UN STRING RESPECTA UN ANUMIT PATTERN
--
-- -- STRING CU 3 CARACTERE, UNDE AL 3-LEA CARACTER ESTE 'B' (__B)
-- -- STRING CU CEL PUTIN 3 CARACTERE, UNDE AL 2-LEA CARACTER ESTE 'B' (_B_%)
--
-- --16
-- SELECT FIRST_NAME
-- FROM EMPLOYEES
-- WHERE UPPER(FIRST_NAME) LIKE '__A%';
--
-- --17
-- SELECT FIRST_NAME
-- FROM EMPLOYEES
-- WHERE UPPER(FIRST_NAME) LIKE '%L%L%' AND
--         (DEPARTMENT_ID = 50 OR MANAGER_ID = 102);
--
-- --18
-- SELECT FIRST_NAME, JOB_ID, SALARY
-- FROM EMPLOYEES
-- WHERE UPPER(JOB_ID) LIKE '%CLERK%'
--         OR UPPER(JOB_ID) LIKE '%REP%' AND
--         (SALARY NOT IN (1000, 2000, 3000));

-- lab2
-- SELECT LENGTH(FIRST_NAME)
-- FROM EMPLOYEES

-- 1
-- SELECT
--     FIRST_NAME || LAST_NAME || 'CASTIGA'|| SALARY
-- FROM EMPLOYEES;
--
-- SELECT CONCAT(CONCAT(CONCAT(FIRST_NAME , LAST_NAME),'CASTIGA'),SALARY)
-- FROM EMPLOYEES;

-- 2
-- SELECT FIRST_NAME, LAST_NAME,LENGTH(LAST_NAME)
-- FROM EMPLOYEES
-- WHERE UPPER(LAST_NAME) LIKE 'J%' OR UPPER(FIRST_NAME) LIKE 'M%' OR UPPER(FIRST_NAME) LIKE '__A%'
-- ORDER BY LENGTH(LAST_NAME) DESC

-- 3
-- SELECT EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID
-- FROM EMPLOYEES
-- WHERE LOWER(TRIM(FIRST_NAME)) = 'steaven';

-- 4
-- SELECT EMPLOYEE_ID,LAST_NAME,LENGTH(LAST_NAME),INSTR(LOWER(LAST_NAME),'a')
-- FROM EMPLOYEES
-- WHERE LOWER(LAST_NAME) LIKE '%e';

-- 5
-- SELECT EMPLOYEE_ID
-- FROM EMPLOYEES
-- WHERE MOD(TRUNC((SYSDATE - HIRE_DATE), 0 ),7) = 0;

-- 6
-- SELECT EMPLOYEE_ID,LAST_NAME,SALARY,TO_CHAR(SALARY+0.15*SALARY, '99999.99'),ROUND((SALARY+0.15*SALARY)/100,2)
-- FROM EMPLOYEES
-- WHERE MOD(SALARY, 1000) !=0;

-- 7 -tema
-- SELECT LAST_NAME,SALARY,  RPAD('$', FLOOR(salary / 1000), '$') AS "Nivel venit"
-- FROM EMPLOYEES;

--8
-- SELECT TO_CHAR(SYSDATE + 30, 'Month DD, YYYY HH24:MI:SS') AS "Data peste 30 zile"
-- FROM DUAL;

--9
-- SELECT LAST_DAY(SYSDATE) - SYSDATE AS "Zile ramase"
-- FROM DUAL;

-- 10
-- A
-- SELECT SYSDATE + INTERVAL '12' HOUR AS "PESTE 12 ORE"
-- FROM DUAL;

-- B
-- SELECT SYSDATE + INTERVAL '5' MINUTE AS "PESTE 5 MIN"
-- FROM DUAL;

-- 11
-- SELECT FIRST_NAME || ' ' || LAST_NAME AS "Nume complet",
--        HIRE_DATE,
--        NEXT_DAY(ADD_MONTHS(HIRE_DATE, 6), 'Monday') AS "Negociere"
-- FROM EMPLOYEES;

-- 12
-- SELECT LAST_NAME,
--        ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) AS "Luni lucrate"
-- FROM EMPLOYEES
-- ORDER BY 2 DESC;

-- 13
-- SELECT LAST_NAME,HIRE_DATE,
--        TO_CHAR(HIRE_DATE,'DATE') AS 'Zi'
-- FROM EMPLOYEES
-- ORDER BY TO_CHAR(hire_date, 'D');

-- 14
-- SELECT LAST_NAME,HIRE_DATE
-- FROM EMPLOYEES
-- WHERE TO_CHAR(HIRE_DATE,'YYYY')=1987
--
-- -- VAR2
-- SELECT last_name, hire_date
-- FROM employees
-- WHERE EXTRACT(YEAR FROM hire_date) = 1987;

-- 15
-- SELECT LAST_NAME,
--        NVL(TO_CHAR(COMMISSION_PCT), 'Fara comision') AS "Comision"
-- FROM EMPLOYEES;

-- 16
-- SELECT LAST_NAME, SALARY, COMMISSION_PCT,
--        (SALARY + (SALARY * NVL(COMMISSION_PCT, 0))) AS "Venit Lunar"
-- FROM EMPLOYEES
-- WHERE (SALARY + (SALARY * NVL(COMMISSION_PCT, 0))) > 10000;

-- 17
-- SELECT LAST_NAME, JOB_ID, SALARY,
--        CASE
--            WHEN JOB_ID = 'IT_PROG' THEN SALARY * 1.2
--            WHEN JOB_ID = 'SA_REP' THEN SALARY * 1.25
--            WHEN JOB_ID = 'SA_MAN' THEN SALARY * 1.35
--            ELSE salary
--        END AS "Salariu dupa marire"
-- FROM EMPLOYEES;

-- LAB3-REZ LAB2
-- 7
-- SELECT
--     LAST_NAME, SALARY, LPAD('$', SALARY/1000,'$')
-- FROM EMPLOYEES;

-- 8
-- SELECT
--     TO_CHAR(SYSDATE+30, 'MONTH, DD, YYYY, HH24:MI:SS ')
-- FROM DUAL;

-- 9
-- SELECT
--     TO_DATE('2025-12-31','YYYY-MM-DD')- SYSDATE
-- FROM DUAL;

-- 11
-- SELECT
--     CONCAT(LAST_NAME,CONCAT(' ',FIRST_NAME)) AS NUME, HIRE_DATE, NEXT_DAY(ADD_MONTHS(HIRE_DATE,6), 'MONDAY') AS NEGOCIERE
-- FROM EMPLOYEES;

-- 12
-- SELECT
--     LAST_NAME,
--     ROUND(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)) AS "LUNI LUCRATE"
-- FROM EMPLOYEES
-- WHERE SUBSTR(TO_CHAR(HIRE_DATE,'DD-MM-YYYY'),-2) LIKE '9_'
-- ORDER BY "LUNI LUCRATE";

-- 13
-- SELECT FIRST_NAME, LAST_NAME,
--        TO_CHAR(HIRE_DATE, 'Day')
-- FROM EMPLOYEES
-- ORDER BY TO_CHAR(HIRE_DATE,'D');

-- 15
-- SELECT
--     LAST_NAME as 'NUME',DECODE(COMMISSION_PCT,null,'Fara comision') as "Comision"
-- FROM EMPLOYEES;

-- SELECT *
-- FROM EMPLOYEES;

-- 16
-- SELECT LAST_NAME,SALARY,
--        (SALARY+SALARY *NVL(COMMISSION_PCT,0))
-- FROM EMPLOYEES
-- WHERE (SALARY+EMPLOYEES.SALARY*NVL(COMMISSION_PCT,0))>1000;

-- 17

-- LAB 3
-- JOIN
-- VAR1
-- SELECT FIRST_NAME, DEPARTMENT_NAME
-- FROM EMPLOYEES, DEPARTMENTS
-- WHERE EMPLOYEES.DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID;
--
-- -- VAR 2 -CEL  MAI DES
-- SELECT *
-- FROM EMPLOYEES E
-- JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--
-- -- VAR 3
-- SELECT *
-- FROM EMPLOYEES
-- JOIN DEPARTMENTS USING(DEPARTMENT_ID);
--
-- SELECT
--     E.FIRST_NAME, D.DEPARTMENT_ID
-- FROM EMPLOYEES E
-- FULL OUTER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--
-- SELECT * FROM EMPLOYEES;
--
-- SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
-- FROM EMPLOYEES D
-- LEFT JOIN JOBS J on J.JOB_ID = E.JOB_ID;
--
-- -- 1
-- SELECT
--     JOB_TITLE, FIRST_NAME
-- FROM EMPLOYEES E
-- JOIN JOBS J ON E.JOB_ID = J.JOB_ID
-- WHERE E.DEPARTMENT_ID = 30;
--
-- -- 2
-- SELECT FIRST_NAME, DEPARTMENT_NAME
-- FROM EMPLOYEES E
-- JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
-- WHERE LOWER(FIRST_NAME) LIKE '%a%' AND TO_CHAR(HIRE_DATE, 'YYYY')=1990;
--
-- -- 3
-- SELECT E.FIRST_NAME, J.JOB_TITLE, E.DEPARTMENT_ID
-- FROM EMPLOYEES E
-- JOIN JOBS J ON J.JOB_ID= E.JOB_ID
-- JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
-- JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
-- WHERE UPPER(L.CITY)='OXFORD' AND E.COMMISSION_PCT IS NULL;
--
-- -- 4
-- SELECT E.FIRST_NAME, J.JOB_TITLE, TO_CHAR(E.HIRE_DATE,'MON')
-- FROM EMPLOYEES E
-- JOIN JOBS J ON J.JOB_ID=E.JOB_ID
-- WHERE E.SALARY>3000 OR E.SALARY=(J.MIN_SALARY+J.MAX_SALARY)/2;
--
-- -- 5
-- SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.FIRST_NAME, E.LAST_NAME, J.JOB_TITLE
-- FROM EMPLOYEES E
-- JOIN DEPARTMENTS D ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
-- JOIN JOBS J  ON J.JOB_ID=E.JOB_ID
-- WHERE LOWER(D.DEPARTMENT_NAME) LIKE '%ti%' AND E.SALARY BETWEEN 5000 AND 7000
-- ORDER BY D.DEPARTMENT_NAME, E.FIRST_NAME
--
-- -- 6
-- SELECT E.EMPLOYEE_ID AS ANG#,
--        E.FIRST_NAME AS ANGAJAT,
--        M.EMPLOYEE_ID AS MGR#,
--        M.FIRST_NAME AS MANAGER
-- FROM EMPLOYEES E
-- JOIN EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID
--
-- -- 7
-- SELECT E.LAST_NAME, E.HIRE_DATE
-- FROM EMPLOYEES E
-- WHERE E.HIRE_DATE > (SELECT E1.HIRE_DATE
--                      FROM EMPLOYEES E1
--                      WHERE E1.LAST_NAME='GATES')
--
--
-- -- CU JOIN
-- SELECT E.LAST_NAME, E.HIRE_DATE
-- FROM EMPLOYEES E
-- JOIN EMPLOYEES G ON G.HIRE_DATE > G.HIRE_DATE
-- WHERE LOWER(G.LAST_NAME)='GATES';

--8
-- SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
-- FROM EMPLOYEES E
-- JOIN DEPARTMENTS D ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
-- WHERE LOWER(E.LAST_NAME) LIKE '%t%'
-- ORDER BY E.LAST_NAME;

--9
--1
-- SELECT
--     E.LAST_NAME, E.SALARY
-- FROM EMPLOYEES E
-- SELECT E.LAST_NAME, E.FIRST_NAME, E.SALARY, J.JOB_TITLE ,D.DEPARTMENT_ID,L.CITY,C.COUNTRY_NAME
-- FROM EMPLOYEES E
-- JOIN JOBS J ON J.JOB_ID=E.JOB_ID
-- JOIN DEPARTMENTS D ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
-- JOIN LOCATIONS L ON  L.LOCATION_ID=D.LOCATION_ID
-- JOIN COUNTRIES C ON C.COUNTRY_ID=L.COUNTRY_ID
-- WHERE E.MANAGER_ID in (SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE UPPER(LAST_NAME)='KING');

--REZOLVARE
--8
-- SELECT UNIQUE E.EMPLOYEE_ID, E.LAST_NAME, E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
-- FROM EMPLOYEES E
-- JOIN DEPARTMENTS D ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
-- JOIN EMPLOYEES C ON E.DEPARTMENT_ID=C.DEPARTMENT_ID
-- WHERE UPPER(E.LAST_NAME) LIKE '%T%' AND C.LAST_NAME=E.LAST_NAME
-- ORDER BY E.LAST_NAME;

--9
-- SELECT E.LAST_NAME, E.FIRST_NAME, E.SALARY, J.JOB_TITLE ,D.DEPARTMENT_ID,L.CITY,C.COUNTRY_NAME
-- FROM EMPLOYEES E
-- JOIN JOBS J ON J.JOB_ID=E.JOB_ID
-- JOIN DEPARTMENTS D ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
-- JOIN LOCATIONS L ON  L.LOCATION_ID=D.LOCATION_ID
-- JOIN COUNTRIES C ON C.COUNTRY_ID=L.COUNTRY_ID
-- WHERE E.MANAGER_ID in (SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE UPPER(LAST_NAME)='KING');


--
-- SELECT EMPLOYEE_ID, FIRST_NAME
-- FROM EMPLOYEES
-- UNION
-- SELECT DEPARTMENT_ID,DEPARTMENT_NAME
-- FROM DEPARTMENTS;

--1
-- SELECT DEPARTMENT_ID
-- FROM DEPARTMENTS
-- WHERE UPPER(DEPARTMENT_NAME) LIKE '%RE%'
-- UNION
-- SELECT DEPARTMENT_ID
-- FROM DEPARTMENTS
-- JOIN EMPLOYEES ON EMPLOYEES.DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID
-- WHERE EMPLOYEES.JOB_ID='SA_REP';

--2
-- SELECT DEPARTMENT_ID
-- FROM DEPARTMENTS
-- MINUS
-- SELECT DEPARTMENT_ID
-- FROM EMPLOYEES
--
-- SELECT E.EMPLOYEE_ID, D.DEPARTMENT_ID
-- FROM EMPLOYEES E;

--lab 4
--subcereri

--daca folosim o coloana dintr-un tabel din afara tabelului -este sincronizata
--cand in interior nu are ceva ce e in afara-este nesincronizata

--in from si join sunt mereu subcereri sincronizate

 --1
SELECT D.DEPARTMENT_NAME
FROM DEPARTMENTS D
JOIN EMPLOYEES E ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
WHERE UPPER(E.LAST_NAME)='GATES';

SELECT E.LAST_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE UPPER(D.DEPARTMENT_NAME)='SHIPPING';


--=>
SELECT E.LAST_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE D.DEPARTMENT_NAME=(SELECT D.DEPARTMENT_NAME
                            FROM DEPARTMENTS D
                            JOIN EMPLOYEES E ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
                            WHERE UPPER(E.LAST_NAME)='GATES'
                            );

--2
SELECT
    E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY,(
        SELECT M.FIRST_NAME
        FROM EMPLOYEES M
        WHERE M.MANAGER_ID=E.EMPLOYEE_ID
    )
FROM EMPLOYEES E;

--3
SELECT E.FIRST_NAME || E.LAST_NAME
FROM EMPLOYEES E
WHERE SALARY > ALL(SELECT
                    --MAX(SALARY)
                SALARY
                FROM EMPLOYEES E1
                WHERE UPPER(E1.JOB_ID) LIKE '%CLERK%'
                );

--lab 6
--4
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME,E.SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
WHERE E.COMMISSION_PCT IS NULL
AND (SELECT E1.COMMISSION_PCT
     FROM EMPLOYEES E1
     WHERE E.MANAGER_ID=E1.EMPLOYEE_ID IS NOT NULL);

--5
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID=E.DEPARTMENT_ID
WHERE HIRE_DATE = (
    SELECT
        MIN(E1.HIRE_DATE)
    FROM EMPLOYEES E1
    WHERE E1.DEPARTMENT_ID=E.DEPARTMENT_ID
    )
ORDER BY DEPARTMENT_NAME;

--6
SELECT
   E.FIRST_NAME, E.DEPARTMENT_ID, E.SALARY
FROM EMPLOYEES E
WHERE ( E.DEPARTMENT_ID, E.SALARY) IN (
    SELECT
        E1.DEPARTMENT_ID, E1.SALARY
    FROM EMPLOYEES E1
    WHERE E1.COMMISSION_PCT IS NOT NULL
    AND E.EMPLOYEE_ID != E1.EMPLOYEE_ID);

--7
SELECT
   E1.FIRST_NAME,E1.SALARY,
        (
        SELECT
            E3.FIRST_NAME
        FROM EMPLOYEES E3
        WHERE E3.SALARY = (
            SELECT
                MAX(SALARY)
            FROM EMPLOYEES E4
            WHERE E4.DEPARTMENT_ID = E3.DEPARTMENT_ID
            AND E4.EMPLOYEE_ID != E3.EMPLOYEE_ID
            )
    )
FROM EMPLOYEES E1
JOIN EMPLOYEES E2 ON E1.EMPLOYEE_ID=E2.EMPLOYEE_ID
WHERE E1.MANAGER_ID IN (
SELECT
    E.EMPLOYEE_ID
FROM EMPLOYEES E
WHERE E.MANAGER_ID IS NULL);

--8
--ROWNUM -A CATA INREGISTRARE ESTE (NR DE ORDINE AL UNEI LINII IN REZULTAT)

--9
SELECT LAST_NAME, FIRST_NAME, SALARY
FROM (SELECT *
     FROM EMPLOYEES
     ORDER BY SALARY DESC)
WHERE ROWNUM<=7
ORDER BY SALARY;


SELECT SALARY, FIRST_NAME, LAST_NAME
FROM EMPLOYEES

WHERE SALARY IN (SELECT SALARY
         FROM ( SELECT DISTINCT SALARY
                FROM EMPLOYEES
                ORDER BY SALARY DESC)
         WHERE ROWNUM <=7)
ORDER BY SALARY;

--10
SELECT LAST_NAME, FIRST_NAME
FROM EMPLOYEES
WHERE SALARY IN (SELECT SALARY
         FROM ( SELECT DISTINCT SALARY
                FROM EMPLOYEES
                ORDER BY SALARY DESC)
         WHERE ROWNUM <=7);

 SELECT SALARY,EMPLOYEE_ID
 FROM EMPLOYEES
 WHERE SALARY=(
 SELECT SALARY
 FROM(SELECT SALARY
        FROM ( SELECT DISTINCT SALARY
                FROM EMPLOYEES
                ORDER BY SALARY DESC)
         WHERE ROWNUM <=7
        ORDER BY SALARY ASC)
 WHERE ROWNUM =1)

--LAB 5
-- where face filtrarea inainte de grupare
-- having face filtrarea dupa grupare
-- fct grup -max,min,sum,average,count
-- fct grup rpimesc ca parametrii numai coloane

-- 1
SELECT
    COUNT(DISTINCT E.MANAGER_ID)
FROM EMPLOYEES E;

-- 2
SELECT
    E1.EMPLOYEE_ID, E1.FIRST_NAME
FROM EMPLOYEES E1
WHERE E1.SALARY > (
    SELECT
        SUM(E.SALARY)/COUNT(E.EMPLOYEE_ID)
    FROM EMPLOYEES E
    );

-- 3
SELECT
    E.MANAGER_ID, MIN(E.SALARY)
FROM EMPLOYEES E
WHERE E.MANAGER_ID IS NOT NULL
GROUP BY E.MANAGER_ID
HAVING MIN(E.SALARY) > 4000
ORDER BY MIN(E.SALARY) DESC;

-- 4
 SELECT MAX(AVG(SALARY))
 FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID;


-- 5
SELECT
    E.JOB_ID,SUM(E.SALARY),D.DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID > 80
GROUP BY D.DEPARTMENT_NAME, E.JOB_ID;

-- 6
SELECT
    SUM(E.COMMISSION_PCT)/COUNT(E.EMPLOYEE_ID)
FROM EMPLOYEES E
GROUP BY E.COMMISSION_PCT;

-- 7
SELECT
    E.DEPARTMENT_ID, D.DEPARTMENT_NAME, COUNT(E.EMPLOYEE_ID)
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE D.DEPARTMENT_ID IN(
SELECT
    E1.DEPARTMENT_ID
FROM EMPLOYEES E1
GROUP BY E1.DEPARTMENT_ID
HAVING COUNT(E1.EMPLOYEE_ID)<4
)
GROUP BY E.DEPARTMENT_ID, D.DEPARTMENT_NAME;


SELECT
    E.DEPARTMENT_ID,
    D.DEPARTMENT_NAME,
    COUNT(E.EMPLOYEE_ID)
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY E.DEPARTMENT_ID, D.DEPARTMENT_NAME
HAVING COUNT(E.EMPLOYEE_ID) < 4;


-- 8
SELECT
    E1.JOB_ID,J.JOB_TITLE,AVG(E1.SALARY)
FROM EMPLOYEES E1
JOIN JOBS J ON E1.JOB_ID = J.JOB_ID
GROUP BY E1.JOB_ID, J.JOB_TITLE
HAVING AVG(E1.SALARY) = (
SELECT MIN(AVG(E.SALARY))
FROM EMPLOYEES E
GROUP BY E.JOB_ID);

--9
SELECT
    D.DEPARTMENT_NAME, MIN(E.SALARY)
FROM EMPLOYEES E
JOIN DEPARTMENTS D on D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME
HAVING AVG(E.SALARY) = (
    SELECT
        MAX(AVG(SALARY))
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID
    );

--10
SELECT
    T.DEPARTMENT_ID, D.DEPARTMENT_NAME, T.CNT, T.SAL, E.EMPLOYEE_ID, E.SALARY, E.JOB_ID
FROM EMPLOYEES E
JOIN (
        SELECT
            E2.DEPARTMENT_ID, COUNT(*) CNT, AVG(E2.SALARY) SAL
        FROM EMPLOYEES E2
        GROUP BY E2.DEPARTMENT_ID
    )T ON E.DEPARTMENT_ID = T.DEPARTMENT_ID
JOIN DEPARTMENTS D on E.DEPARTMENT_ID = D.DEPARTMENT_ID




--LAB 6

------------------------LCD
-- COMMIT -> PERMANENTIZEAZA MODIFICARILE
-- ROLLBACK -> ANULEAZA MODIFICARILE PANA LA ULTIMUL COMMIT EXECUTAT
-- SAVEPOINT -> MARCHEAZA PUNCT INTERMEDIAR IN TRANZACTIE (SE POATE FACE ROLLBACK DOAR PANA LA PUNCTUL RESPECTIV)

-- PRIN MODIFICARI SE INTELEGE APLICAREA COMENZILOR: INSERT, UPDATE, DELETE
-- RULAREA UNEI COMENZI DE TIP LDD (CREATE, ALTER, DROP, TRUNCATE, RENAME) ADUCE IMPLICIT SI RULAREA UNUI COMMIT


    --EXEMPLU 1
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- COMMIT => TABEL_TEST(1,2)
-- ROLLBACK => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- ROLLBACK => TABEL_TEST(1,2)

    --EXEMPLU 2
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- CREATE (+COMMIT IMPLICIT) => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- SAVEPOINT P
-- INSERT (4) => TABEL_TEST(1,2,3,4)
-- ROLLBACK TO P => TABEL_TEST(1,2,3)

    --EXEMPLU 3
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- CREATE (+COMMIT IMPLICIT) => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- SAVEPOINT P
-- INSERT (4) => TABEL_TEST(1,2,3,4)
-- ROLLBACK => TABEL_TEST(1,2)

    --EXEMPLU 4
-- TABEL_TEST ()
-- INSERT 1 => TABEL_TEST(1)
-- INSERT 2 => TABEL_TEST(1,2)
-- SAVEPOINT P
-- CREATE (+COMMIT IMPLICIT) => TABEL_TEST(1,2)
-- INSERT (3) => TABEL_TEST(1,2,3)
-- INSERT (4) => TABEL_TEST(1,2,3,4)
-- ROLLBACK TO P => EROARE COMPILARE

-------------------------LDD
    --CREARE TABELE

    -- METODA 1
-- MAI INTAI SE TRECE LISTA DE COLOANE, IAR PE URMA LISTA DE CONSTRANGERI LA NIVEL DE TABEL
-- PENTRU FIECARE COLOANA SE SPECIFICA NUMELE, TIPUL DE DATE SI EVENTUAL O VALOARE DEFAULT SAU O CONSTRANGERE LA NIVEL DE COLOANA
-- CONSTRANGERILE LA NIVEL DE COLOANA POT LUCRA DOAR CU COLOANA IN DREPTUL CAREIA ESTE TRECUTA
-- CONSTRANGERILE LA NIVEL DE TABEL POT LUCRA CU MAI MULTE COLOANE ALE TABELULUI
    -- (CUM AR FI PRIMARY KEY-URILE COMPUSE SAU CONSTRANGERILE DE TIP CHECK A CAROR CONDITIE LUCREAZA CU MAI MULTE COLAONE ALE TABELULUI)

CREATE TABLE ECHIPE (
    ID_ECHIPA NUMBER(10),
    NUME_ECHIPA VARCHAR2(10) NOT NULL, --CONSTRANGERE LA NIVEL DE COLOANA
    DATA_INFIINTARE DATE DEFAULT SYSDATE,
    VENIT_ANUAL NUMBER(10, 2),
    ABREVIERE_NUME VARCHAR2(3) CONSTRAINT VERIF_LG CHECK ( LENGTH(ABREVIERE_NUME) = 3), --CONSTRANGERE LA NIVEL DE COLOANA
    CONSTRAINT CHEIE_PRIMARA PRIMARY KEY (ID_ECHIPA), --CONSTRANGERE LA NIVEL DE TABEL
    CHECK ( VENIT_ANUAL > 100000 ) --CONSTRANGERE LA NIVEL DE TABEL
);
-- CONSTRANGERILE DE TIP NOT NULL SE PUN DOAR LA NIVEL DE COLOANA
-- CONSTRANGEREA DE LA LINIA 62 VA FI SALVATA CU NUMELE 'CHEIE_PRIMARA'
-- CONSTRANGEREA DE LA LINIA 63 VA FI SALVATA CU NUMELE 'SYS_...'
-- PENTRU A DA UN NUME PARTICULAR UNEI CONSTRANGERI SE FOLOSESTE SINTAXA 'CONSTRAINT <nume constrangere> <sintaxa specifica constrangerii respective>'

-- ATUNCI CAND SE FACE UN INSERT IMPLICIT, NESPECIFICANDU-SE O VALOARE PENTRU O COLOANA, ACEASTA VA PRIMI VALOAREA NULL,
    -- DAR DACA ESTE DEFINITA O VALOARE DEFAULT PE COLOANA RESPECTIVA, IN LOC DE NULL SE VA INSERA VALOAREA DEFAULT

CREATE TABLE JUCATORI (
    ID_JUCATOR NUMBER(10),
    NUME_JUCATOR VARCHAR2(10),
    NUMAR_TRICOU NUMBER(10),
    ECHIPA_ID NUMBER(10),
    CONSTRAINT CHEIE_PRIMARA_2 PRIMARY KEY (ID_JUCATOR),
    CONSTRAINT NR_TRICOU_UNIC UNIQUE (NUMAR_TRICOU),
    CONSTRAINT FK_JUC_ECH FOREIGN KEY (ECHIPA_ID)
            REFERENCES ECHIPE(ID_ECHIPA)
);

-- ATENTIE! CONSTRANGERILE TREBUIE SA AIBE NUME UNIC LA NIVELUL SERVERULUI, NU AL TABELULUI
    -- DACA IN 'ECHIPE' AM O CONSTRANGERE CU NUMELE 'CHEIE_PRIMARA', NU POT AVEA SI IN ALTE TABELE CONSTRANGERI CU ACEASTA DENUMIRE
-- IN CAZUL CONSTRANGERILOR DE TIP FOREIGN KEY SE POATE FACE REFERINTA DOAR CATRE COLOANE CARE IN TABELUL REFERENTIAT AU CONSTRANGERE DE TIP PRIMARY KEY SAU UNIQUE

--METODA 2
CREATE TABLE COPIE_EMPLOYEES AS
    SELECT EMPLOYEE_ID, SALARY * 12
    FROM EMPLOYEES; -- SE VA CREA UN TABEL CARE VA AVEA STRUCTURA DETERMINATA DE CAMPURILE DIN CLAUZA SELECT SI VA CONTINE INREGISTRARILE SUBCERERII SPECIFICATE (SELECT)
-- ATUNCI CAND SE CREEAZA UN TABEL CU ACEASTA METODA, SE VOR PRELUA DIN TABELUL/TABELELE DIN CLAUZA FROM DOAR CONSTRANGERILE DE TIP NOT NULL


    -- MODIFICARE LA NIVEL STRUCTURAL A TABELELOR (LA NIVEL DE COLOANE SAU CONSTRANGERI)
--ALTER
    -- ADAUGARE COLOANE
ALTER TABLE JUCATORI
ADD NR_GOLURI NUMBER(10) DEFAULT 0;

    -- MODIFICARE COLOANA (TIP DE DATE, DIMENSIUNE, VALOARE DEFAULT)
ALTER TABLE JUCATORI
MODIFY NR_GOLURI VARCHAR2(10); --DOAR DACA PE COLOANA RESPECTIVA NU EXISTA VALORI NENULE SAU IN TABEL NU EXISTA INREGISTRARI

ALTER TABLE JUCATORI
MODIFY NR_GOLURI NUMBER(5); --DOAR DACA PE COLOANA RESPECTIVA NU EXISTA VALORI NENULE SAU IN TABEL NU EXISTA INREGISTRARI

ALTER TABLE JUCATORI
MODIFY NR_GOLURI VARCHAR2(5); --DOAR DACA PE COLOANA RESPECTIVA NU EXISTA VALORI NENULE SAU IN TABEL NU EXISTA INREGISTRARI SAU SIRURILE DEJA EXISTENTE RESPECTA NOUA DIMENSIUNE

ALTER TABLE JUCATORI
MODIFY NR_GOLURI VARCHAR2(15); --CRESTEREA DIMENSIUNII SE POATE FACE ORICAND

    -- STERGERE COLOANE
ALTER TABLE JUCATORI
DROP COLUMN NR_GOLURI;

    -- ADAUGARE CONSTRANGERI
ALTER TABLE JUCATORI
ADD (
        CONSTRAINT VERIF_NR_TRICOU CHECK ( NUMAR_TRICOU >= 1 AND NUMAR_TRICOU <= 99 ),
        CONSTRAINT LG_NUME CHECK ( LENGTH(NUME_JUCATOR) >= 5 )
    );

    -- STERGERE CONSTRANGERI
ALTER TABLE JUCATORI
DROP CONSTRAINT LG_NUME;

    -- DEZACTIVARE CONSTRANGERI
-- ATENTIE! ATUNCI CAND DEZACTIVATI O CONSTRANGERE SI MODIFICATI DATELE TABELULUI, IN MOMENTUL IN CARE O REACTIVATI ESTE NECESAR CA DATELE MODIFICATE SA RESPECTE CONDITIA IMPUSA DE CONSTRANGERE, IN CAZ CONTRAR, NU SE VA PUTEA REACTIVA
ALTER TABLE JUCATORI
DISABLE CONSTRAINT VERIF_NR_TRICOU;

ALTER TABLE JUCATORI
ENABLE CONSTRAINT VERIF_NR_TRICOU;

    -- STERGEREA TABELELOR
--DROP
-- ATENTIE! ATUNCI CAND STERGETI UN TABEL, TREBUIE SA FIE MAI INTAI STERSE SI CONSTRANGERILE DE TIP FOREIGN KEY CARE REFERENTIAZA CATRE TABELUL IN CAUZA (IN ACEST CAZ, CONSTRANGEREA DE TIP FK DIN JUCATORI)
DROP TABLE ECHIPE;


--LAB 7

--COMANDA INSERT
CREATE TABLE JUCATORI_LAB_NOU (
    ID_JUCATOR NUMBER(10),
    NUME VARCHAR2(10),
    SALARIU NUMBER(10) DEFAULT 500
);

INSERT INTO JUCATORI_LAB_NOU (ID_JUCATOR, NUME, SALARIU)
VALUES (1, 'A', 1000); -- SE VA INSERA JUCATORUL (1, A, 1000)

INSERT INTO JUCATORI_LAB_NOU (ID_JUCATOR, NUME)
VALUES (2, 'B'); -- SE VA INSERA JUCATORUL (2, B, 500)

INSERT INTO JUCATORI_LAB_NOU (ID_JUCATOR, NUME, SALARIU)
VALUES (3, 'C', NULL); -- SE VA INSERA JUCATORUL (3, C, NULL)

INSERT INTO JUCATORI_LAB_NOU
VALUES (4, 'D', NULL); -- SE VA INSERA JUCATORUL (4, D, NULL)

--1
CREATE TABLE D_pnu AS SELECT * FROM DEPARTMENTS;
-- CAND CREAM UN TABEL CU ACEASTA METODA SE COPIAZA STRUCTURA DEFINITA DE CAMPURILE DIN CLAUZA SELECT SI NUMAI CONSTRANGERILE DE TIP NOT NULL AFERENTE ACESTOR CAMPURI IN TABELUL/TABELELE DIN CLAUZA FROM

INSERT INTO D_pnu
VALUES (300, 'Programare', null, null); --EROARE: NOT ENOUGH VALUES;
--NU ESTE SPECIFICATA LISTA DE COLOANE, DECI BY DEFAULT SUNT LUATE IN CONSIDERARE TOATE COLOANELE
--SOLUTIE:
--  SE DAU VALORI PENTRU TOATE CELE 4 COLOANE
--  SE DAU VALORI DOAR PENTRU CELE 2 COLOANE MENTIONATE, RESPECTANDU-SE TOATE CONSTRANGERILE TABELULUI

INSERT INTO D_pnu (department_id, department_name)
VALUES (300, 'Programare'); --OK; COLOANELE CARE NU AU FOST PRECIZATE VOR PRIMI NULL (ATENTIE LA CONSTRANGERI)

INSERT INTO D_pnu (department_name, department_id)
VALUES ('Programare', 300);
--  OK; SE POATE MODIFICA ORDINEA COLOANELOR; IMPORTANT ESTE SA COINCIDA CA TIP DE DATE (SAU SA SE POATA FACE CONVERSIE IMPLICITA A TIPULUI DE DATE)
--      DE ASEMENEA, DEOARECE NU A FOST DEFINITA CHEIE PRIMARA, SE POATE INTRODUCE UN NOU DEPARTAMENT CU ID-UL 300

INSERT INTO D_pnu (department_id, department_name, location_id)
VALUES (300, 'Programare', null); --OK;

INSERT INTO D_pnu (department_name, location_id)
VALUES ('Programare', null); --OK; COLOANELE CARE NU AU FOST PRECIZATE VOR PRIMI NULL (ATENTIE LA CONSTRANGERI)
-- ATENTIE LA URMATORUL ASPECT! DACA PE COLOANA DEPARTMENT_ID S-AR FI DEFINIT CONSTRANGERE DE CHEIE PRIMARA ATUNCI AR FI FOST EROARE
        --COLOANA DEPARTMENT_ID NU A FOST PRECIZATA, DECI BY DEFAULT PRIMESTE NULL
        --DAR ACEASTA ESTE CHEIA PRIMARA A TABELULUI, IAR CHEIA PRIMARA NU POATE FI NULL

--2
CREATE TABLE E_PNU AS SELECT * FROM EMPLOYEES;

INSERT INTO E_PNU (employee_id, last_name, email, hire_date, job_id, salary, commission_pct) -- S-AU SPECIFICAT COLOANELE CARE AU CONSTRANGERE DE TIP NOT NULL
VALUES (    (
                SELECT MAX(EMPLOYEE_ID) + 1
                FROM EMPLOYEES
            ),
        'NUME', 'nume@emp.com',SYSDATE, 'SA_REP', 5000, NULL);

--3
CREATE TABLE EMP_COPY AS
    SELECT *
    FROM EMPLOYEES
    WHERE 1 = 0;

INSERT INTO EMP_COPY
    SELECT *
    FROM EMPLOYEES
    WHERE SALARY >= 10000;

--4
CREATE TABLE EMP0_COPY AS
    SELECT *
    FROM EMPLOYEES
    WHERE 1 = 0;

CREATE TABLE EMP1_COPY AS
    SELECT *
    FROM EMPLOYEES
    WHERE 1 = 0;

CREATE TABLE EMP2_COPY AS
    SELECT *
    FROM EMPLOYEES
    WHERE 1 = 0;

CREATE TABLE EMP3_COPY AS
    SELECT *
    FROM EMPLOYEES
    WHERE 1 = 0;

INSERT FIRST
    WHEN DEPARTMENT_ID = 80 THEN INTO EMP0_COPY
    WHEN SALARY < 5000 THEN INTO EMP1_COPY
    WHEN SALARY >= 5000 AND SALARY <= 10000 THEN INTO EMP2_COPY
    WHEN SALARY > 10000 THEN INTO EMP3_COPY
SELECT * FROM EMPLOYEES;

INSERT ALL
    WHEN DEPARTMENT_ID = 80 THEN INTO EMP0_COPY
    WHEN SALARY < 5000 AND DEPARTMENT_ID <> 80 THEN INTO EMP1_COPY
    WHEN SALARY > 5000 AND SALARY < 10000 AND DEPARTMENT_ID <> 80 THEN INTO EMP2_COPY
    WHEN SALARY > 10000 AND DEPARTMENT_ID <> 80 THEN INTO EMP3_COPY
SELECT *
FROM EMPLOYEES;

--COMANDA UPDATE
UPDATE E_pnu
SET (SALARY, COMMISSION_PCT) = (
                                SELECT
                                    1000, NULL
                                FROM DUAL
                                )
WHERE EMPLOYEE_ID = 100;

UPDATE E_pnu
SET SALARY = 1000, COMMISSION_PCT = NULL
WHERE EMPLOYEE_ID = 100;

--5
UPDATE E_pnu
SET SALARY = SALARY * 1.05;

--6
UPDATE E_pnu
SET SALARY = SALARY + 1000
WHERE UPPER(FIRST_NAME) = 'DOUGLAS' AND
      UPPER(LAST_NAME) = 'GRANT';

UPDATE D_pnu
SET MANAGER_ID = (
        SELECT EMPLOYEE_ID
        FROM EMPLOYEES
        WHERE UPPER(FIRST_NAME) = 'DOUGLAS' AND
                UPPER(LAST_NAME) = 'GRANT'
    )
WHERE DEPARTMENT_ID = 20;

--7
UPDATE E_PNU
SET (JOB_ID, DEPARTMENT_ID) = (
        SELECT JOB_ID, DEPARTMENT_ID
        FROM EMPLOYEES
        WHERE EMPLOYEE_ID = 205
    )
WHERE EMPLOYEE_ID = 114;

--COMANDA DELETE
DELETE FROM E_pnu
WHERE SALARY < 5000;

DELETE FROM EMPLOYEES;
TRUNCATE TABLE EMPLOYEES;
--CELE 2 COMENZI DE MAI SUS PRODUC ACELASI EFECT (STERGEREA DATELOR DIN TABEL)
--DIFERENTA: DUPA EXECUTAREA LUI TRUNCATE SE INCHEIE O TRANZACTIE SI SE PERMANENTIZEAZA MODIFICARILE (COMMIT IMPLICIT)

--8
DELETE FROM DEPARTMENTS; --EROARE: integrity constraint violated - child record found

--DIN CAUZA FOREIGN KEY-ULUI STABILIT INTRE TABELELE DEPARTMENTS SI EMPLOYEES,
--POT FI STERSE DOAR ACELE INREGISTRARI CARE NU APAR IN TABELUL COPIL(EMPLOYEES)

DELETE FROM DEPARTMENTS
WHERE DEPARTMENT_ID NOT IN
      (
        SELECT DEPARTMENT_ID
        FROM EMPLOYEES
        WHERE DEPARTMENT_ID IS NOT NULL --ACEASTA CONDITIE S-A ADAUGAT DEOARECE EXISTA ANGAJATI FARA DEPARTAMENT,
            -- IAR ATUNCI CAND SE VERIFICA DEP_ID NOT IN (10, 20, NULL, ...) REZULTATUL VA FI UNKNOWN, NU TRUE/FALSE
    );

DELETE FROM DEPARTMENTS D
WHERE (
        SELECT COUNT(*)
        FROM EMPLOYEES E
        WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
          ) = 0;

--9
DELETE FROM E_PNU
WHERE COMMISSION_PCT IS NULL;]

--SECVENTE
--1
CREATE SEQUENCE SEQ_DEPT
START WITH 400
INCREMENT BY 10
MAXVALUE 10000
NOCACHE NOCYCLE ;

SELECT SEQ_DEPT.currval FROM DUAL;

--2
CREATE SEQUENCE SEQ_EMP
START WITH 1
MAXVALUE 21
CYCLE ;

UPDATE EMPLOYEES
SET SALARY = SEQ_EMP.nextval;

--3
DROP SEQUENCE SEQ_DEPT;

----UTILIZARE SECVENTE PENTRU INSERARE DATE

CREATE TABLE TEST_SECV_INSERT (
    COL1 NUMBER(10) PRIMARY KEY,
    COL2 NUMBER(10)
)

CREATE SEQUENCE SECV_INSERT
START WITH 1
INCREMENT BY 1;

INSERT INTO TEST_SECV_INSERT
VALUES (SECV_INSERT.nextval, 1000);

INSERT INTO TEST_SECV_INSERT
VALUES (SECV_INSERT.nextval, 2000);

INSERT INTO TEST_SECV_INSERT
VALUES (SECV_INSERT.nextval, 3000);

INSERT INTO TEST_SECV_INSERT
VALUES (SECV_INSERT.nextval, 4000);

SELECT * FROM TEST_SECV_INSERT;
-- 1,1000
-- 2,2000
-- 3,3000
-- 4,4000
-- ATENTIE, daca pentru un insert a aparut eroare, valoarea secventei tot va creste




--LAB 8

--CLAUZA WITH SI OPERATORUL EXISTS
--1
SELECT *
FROM EMPLOYEES E3
WHERE E3.DEPARTMENT_ID IN (
    SELECT
        DISTINCT E2.DEPARTMENT_ID
    FROM EMPLOYEES E2
    WHERE E2.SALARY = (
        SELECT
            MAX(E.SALARY)
        FROM EMPLOYEES E
        WHERE E.DEPARTMENT_ID = 30
        )
    );

SELECT *
FROM EMPLOYEES E
WHERE EXISTS(
        SELECT *
        FROM EMPLOYEES E2
        WHERE E2.SALARY = (
            SELECT
                MAX(E4.SALARY)
            FROM EMPLOYEES E4
            WHERE E4.DEPARTMENT_ID = 30) AND
              E2.DEPARTMENT_ID = E.DEPARTMENT_ID
          );

--2
WITH TABLE_SECUND AS (
    SELECT D.DEPARTMENT_NAME, SUM(E.SALARY) "SUMA TOTALA"
    FROM EMPLOYEES E
    JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    GROUP BY D.DEPARTMENT_NAME
)
SELECT *
FROM TABLE_SECUND T
WHERE T."SUMA TOTALA" > (
        SELECT AVG(T2."SUMA TOTALA")
        FROM TABLE_SECUND T2
    );

--SUBCERERI IERARHICE
--     100
--101       102
--103     104 105

--START WITH EMPLOYEE_ID = 100 -> 100LVL1, 101LVL2
--START WITH EMPLOYEE_ID = 101 -> 101LVL1, 103LVL2

--1
--A
SELECT
    E.EMPLOYEE_ID, E.MANAGER_ID, LEVEL
FROM EMPLOYEES E
WHERE LEVEL > 1
START WITH E.LAST_NAME = 'De Haan'
CONNECT BY PRIOR E.EMPLOYEE_ID = E.MANAGER_ID;

--B
SELECT
    E.EMPLOYEE_ID, E.MANAGER_ID, LEVEL
FROM EMPLOYEES E
WHERE LEVEL = 2
START WITH E.LAST_NAME = 'De Haan'
CONNECT BY PRIOR E.EMPLOYEE_ID = E.MANAGER_ID;

--C
SELECT
    E.EMPLOYEE_ID, E.MANAGER_ID, LEVEL
FROM EMPLOYEES E
WHERE LEVEL = 3
START WITH E.LAST_NAME = 'De Haan'
CONNECT BY PRIOR E.EMPLOYEE_ID = E.MANAGER_ID;

--2
SELECT
    E.EMPLOYEE_ID, E.MANAGER_ID, LEVEL
FROM EMPLOYEES E
CONNECT BY PRIOR E.MANAGER_ID = E.EMPLOYEE_ID;

--3
SELECT
    E2.EMPLOYEE_ID, (
        SELECT
            COUNT(*) - 1
        FROM EMPLOYEES E
        START WITH E.EMPLOYEE_ID = E2.EMPLOYEE_ID
        CONNECT BY PRIOR E.EMPLOYEE_ID = E.MANAGER_ID
    )
FROM EMPLOYEES E2;

--GROUP BY ROLLUP(x, y, z) -> x,y,z / x,y / x / total
--GROUP BY ROLLUP(x, y) -> x,y / x / total
--GROUP BY CUBE(x, y, z) -> x,y,z / x,y / x,z / x / y,z / y / z / total
--GROUP BY CUBE(x, y) -> x,y / y,x / x / y / total

--1.
SELECT
    D.DEPARTMENT_NAME, J.JOB_TITLE, AVG(E.SALARY),
    GROUPING(D.DEPARTMENT_NAME), GROUPING(J.JOB_TITLE)
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN JOBS J ON E.JOB_ID = J.JOB_ID
GROUP BY ROLLUP(D.DEPARTMENT_NAME, J.JOB_TITLE);

--2
SELECT
    D.DEPARTMENT_NAME, J.JOB_TITLE, AVG(E.SALARY),
    CASE
        WHEN GROUPING(D.DEPARTMENT_NAME) = 1 AND GROUPING(J.JOB_TITLE) = 1 THEN 'NICIUNA'
        WHEN GROUPING(D.DEPARTMENT_NAME) = 1 AND GROUPING(J.JOB_TITLE) = 0 THEN 'JOB'
        WHEN GROUPING(D.DEPARTMENT_NAME) = 0 AND GROUPING(J.JOB_TITLE) = 1 THEN 'DEP'
        WHEN GROUPING(D.DEPARTMENT_NAME) = 0 AND GROUPING(J.JOB_TITLE) = 0 THEN 'DEPJOB'
    END
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN JOBS J ON E.JOB_ID = J.JOB_ID
GROUP BY CUBE(D.DEPARTMENT_NAME, J.JOB_TITLE);

--3.
SELECT
    D.DEPARTMENT_NAME, J.JOB_TITLE, D.MANAGER_ID,
    MAX(E.SALARY), SUM(E.SALARY)
FROM DEPARTMENTS D
JOIN EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN JOBS J ON E.JOB_ID = J.JOB_ID
GROUP BY GROUPING SETS((D.DEPARTMENT_NAME, J.JOB_TITLE), (J.JOB_TITLE, D.MANAGER_ID), ());




--LAB 9

--DIVISION

    -- PROIECTE
--(1, 10000)
--(2, 10000)
--(3, 5000)
    -- ANGAJATI SI PROIECTELE LA CARE AU LUCRAT
--(A, 1), (A, 2), (A, 3)
--(B, 1), (B, 2)
--(C, 1), (C, 3)

--METODA 2
SELECT
    DISTINCT W.EMPLOYEE_ID
FROM WORKS_ON W
WHERE NOT EXISTS(
    (
        SELECT
            P.PROJECT_ID
        FROM PROJECTS P
        WHERE P.BUDGET = 10000
    )
    MINUS
    (
        SELECT
            W2.PROJECT_ID
        FROM WORKS_ON W2
        WHERE W2.EMPLOYEE_ID = W.EMPLOYEE_ID
    )
)

--METODA 4
SELECT W.EMPLOYEE_ID
FROM WORKS_ON W
--(A, 1), (A, 2), (A, 3)
--(B, 1), (B, 2)
--(C, 1), (C, 3)
WHERE W.PROJECT_ID IN (
        SELECT
            P.PROJECT_ID
        FROM PROJECTS P
        WHERE P.BUDGET = 10000
    )
--(A, 1), (A, 2) -> 2 = 2 -> DA
--(B, 1), (B, 2) -> 2 = 2 -> DA
--(C, 1) -> 1 = 2 -> NU
GROUP BY W.EMPLOYEE_ID
HAVING COUNT(*) = (
        SELECT
            COUNT(P.PROJECT_ID)
        FROM PROJECTS P
        WHERE P.BUDGET = 10000
    );


--1
--METODA2
SELECT W.EMPLOYEE_ID, E.LAST_NAME, E.FIRST_NAME
FROM WORKS_ON W
         JOIN EMPLOYEES E ON E.EMPLOYEE_ID = W.EMPLOYEE_ID
WHERE W.PROJECT_ID IN (SELECT P.PROJECT_ID
                       FROM PROJECTS P
                       WHERE TO_CHAR(P.START_DATE, 'YYYY') = 2006
                         AND TO_CHAR(P.START_DATE, 'MM') <= 6)
GROUP BY W.EMPLOYEE_ID, E.LAST_NAME, E.FIRST_NAME
HAVING COUNT(W.PROJECT_ID) = (SELECT COUNT(*)
                              FROM PROJECTS P1
                              WHERE TO_CHAR(P1.START_DATE, 'YYYY') = 2006
                                AND TO_CHAR(P1.START_DATE, 'MM') <= 6);

--METODA4
SELECT DISTINCT W.EMPLOYEE_ID, E.LAST_NAME, E.FIRST_NAME
FROM WORKS_ON W
         JOIN EMPLOYEES E ON E.EMPLOYEE_ID = W.EMPLOYEE_ID
WHERE NOT EXISTS((SELECT P.PROJECT_ID
                  FROM PROJECTS P
                  WHERE TO_CHAR(P.START_DATE, 'YYYY') = 2006
                    AND TO_CHAR(P.START_DATE, 'MM') <= 6)
                 MINUS
                 (SELECT W1.PROJECT_ID
                  FROM WORKS_ON W1
                  WHERE W1.EMPLOYEE_ID = W.EMPLOYEE_ID));

--2
--A
SELECT
    E.FIRST_NAME
FROM
    (
        SELECT
            DISTINCT W1.EMPLOYEE_ID
        FROM WORKS_ON W1
        WHERE NOT EXISTS
                (
                    (
                        SELECT
                            W2.PROJECT_ID
                        FROM WORKS_ON W2
                        WHERE W2.EMPLOYEE_ID = 200
                    )
                    MINUS
                    (
                        SELECT
                            W2.PROJECT_ID
                        FROM WORKS_ON W2
                        WHERE W1.EMPLOYEE_ID = W2.EMPLOYEE_ID
                    )
                )
    )TEMP
JOIN EMPLOYEES E ON E.EMPLOYEE_ID = TEMP.EMPLOYEE_ID;

--b
SELECT
    E.FIRST_NAME
FROM (
        SELECT
        DISTINCT W1.EMPLOYEE_ID
        FROM WORKS_ON W1
        WHERE NOT EXISTS
                (
                    (
                        SELECT
                            W2.PROJECT_ID
                        FROM WORKS_ON W2
                        WHERE W1.EMPLOYEE_ID = W2.EMPLOYEE_ID
                    )
                    MINUS
                    (
                        SELECT
                            W2.PROJECT_ID
                        FROM WORKS_ON W2
                        WHERE W2.EMPLOYEE_ID = 200
                    )
                )
     )TEMP
JOIN EMPLOYEES E ON E.EMPLOYEE_ID = TEMP.EMPLOYEE_ID;

--c
SELECT
    E.FIRST_NAME
FROM (
    SELECT
        DISTINCT W1.EMPLOYEE_ID
    FROM WORKS_ON W1
    WHERE (NOT EXISTS
                    (
                        (
                            SELECT
                                W2.PROJECT_ID
                            FROM WORKS_ON W2
                            WHERE W2.EMPLOYEE_ID = 200
                        )
                        MINUS
                        (
                            SELECT
                                W2.PROJECT_ID
                            FROM WORKS_ON W2
                            WHERE W1.EMPLOYEE_ID = W2.EMPLOYEE_ID
                        )
                    ))
            AND
            (
            NOT EXISTS
                    (
                        (
                            SELECT
                                W2.PROJECT_ID
                            FROM WORKS_ON W2
                            WHERE W1.EMPLOYEE_ID = W2.EMPLOYEE_ID
                        )
                        MINUS
                        (
                            SELECT
                                W2.PROJECT_ID
                            FROM WORKS_ON W2
                            WHERE W2.EMPLOYEE_ID = 200
                        )
            )
            )
            AND W1.EMPLOYEE_ID <>200
         )TEMP
JOIN EMPLOYEES E ON E.EMPLOYEE_ID = TEMP.EMPLOYEE_ID;

---------------VIZUALIZARI
--1
CREATE OR REPLACE VIEW VIZ_EMP30 AS
    SELECT
        E.EMPLOYEE_ID, E.LAST_NAME, E.EMAIL
    FROM EMPLOYEES E
    WHERE E.DEPARTMENT_ID = 30;

INSERT INTO VIZ_EMP30
VALUES (100, 'A', 'A'); --NU MERGE DEOARECE NU RESPECTA CONSTRANGERILE DEFINITE PE TABELUL DE BAZA

--2
CREATE OR REPLACE VIEW VIZ_EMP30 AS
    SELECT
        E.EMPLOYEE_ID, E.LAST_NAME, E.EMAIL, E.HIRE_DATE, E.JOB_ID
    FROM EMPLOYEES E
    WHERE E.DEPARTMENT_ID = 30;

SELECT * FROM VIZ_EMP30;

INSERT INTO VIZ_EMP30
VALUES (100, 'A', 'A', SYSDATE, 'AD_PRES'); --NU MERGE DEOARECE NU E RESPECTATA ACUM CONSTRANGEREA DE CHEIE PRIMARA

INSERT INTO VIZ_EMP30
VALUES (300, 'A', 'A', SYSDATE, 'AD_PRES');


SELECT * FROM EMPLOYEES;
SELECT * FROM VIZ_EMP30; --ANGAJATUL INTRODUS ANTERIOR NU ESTE MOMENTAN VIZIBIL IN VIZUALIZARE DEOARECE NU ESTE IN DEPARTAMENTUL 30

UPDATE EMPLOYEES
SET DEPARTMENT_ID = 30
WHERE EMPLOYEE_ID = 300;
SELECT * FROM VIZ_EMP30; --ANGAJATUL INTRODUS ESTE ACUM VIZIBIL IN VIZUALIZARE DEOARECE ESTE IN DEPARTAMENTUL 30

DELETE FROM VIZ_EMP30 WHERE EMPLOYEE_ID = 300;

--3
CREATE OR REPLACE VIEW VIZ_EMPSAL50 AS
    SELECT
        E.EMPLOYEE_ID COD_ANGAJAT, E.LAST_NAME NUME,
        E.EMAIL, E.JOB_ID FUNCTIE, E.HIRE_DATE DATA_ANGAJARE,
        12 * E.SALARY SAL_ANUAL
    FROM EMPLOYEES E
    WHERE E.DEPARTMENT_ID = 50;

SELECT * FROM VIZ_EMPSAL50;

INSERT INTO VIZ_EMPSAL50
VALUES (300, 'A', 'A', 'AD_PRES', SYSDATE, 300); --ACTUALIZAREA UNEI COLOANE NEACTUALIZABILE (SAL_ANUAL -> DEFINITA PRIN CALCUL)

SELECT * FROM USER_UPDATABLE_COLUMNS
WHERE TABLE_NAME = 'VIZ_EMPSAL50';

INSERT INTO VIZ_EMPSAL50 (COD_ANGAJAT, NUME, EMAIL, FUNCTIE, DATA_ANGAJARE)
VALUES (400, 'B', 'B', 'AD_PRES', SYSDATE); --MERGE DEOARECE SUNT FOLOSITE DOAR COLOANELE ACTUALIZABILE

--4
CREATE OR REPLACE VIEW VIZ_DEPT_SUM AS
    SELECT
        E.DEPARTMENT_ID, SUM(E.SALARY) SUM
    FROM EMPLOYEES E
    GROUP BY E.DEPARTMENT_ID; --NICIO COLOANA NU ESTE ACTUALIZABILE DEOARECE APAR FUNCTII GRUP + GROUP BY

SELECT * FROM USER_UPDATABLE_COLUMNS
WHERE TABLE_NAME = 'VIZ_DEPT_SUM';

CREATE OR REPLACE VIEW VIZ_DEPT_SUM AS
    SELECT
        E.DEPARTMENT_ID, (
            SELECT
                SUM(E2.SALARY)
            FROM EMPLOYEES E2
            WHERE E2.DEPARTMENT_ID = E.DEPARTMENT_ID
        ) SUM
    FROM EMPLOYEES E; --IN ACEST CAZ FUNCTIA GRUP E IN SUBCERERE, DECI DEPARTMENT_ID ESTE ACTUALIZABILA

--5
CREATE OR REPLACE VIEW VIZ_SAL_PNU AS
    SELECT
        E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY, E.SALARY
    FROM EMPLOYEES E
    JOIN DEPARTMENTS D on E.DEPARTMENT_ID = D.DEPARTMENT_ID
    JOIN LOCATIONS L on D.LOCATION_ID = L.LOCATION_ID; --LAST_NAME SI SALARY SUNT SINGURELE COLOANE ACTUALIZABILE DEOARECE APARTIN DE TABELUL EMPLOYEES, CARE ESTE TABELUL KEY-PRESERVED



